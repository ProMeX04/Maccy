import AppKit
import Defaults
import Sauce

class Clipboard {
    static let shared = Clipboard()

    typealias OnNewCopyHook = (HistoryItem) -> Void

    private var onNewCopyHooks: [OnNewCopyHook] = []
    var changeCount: Int

    private let pasteboard = NSPasteboard.general

    private var timer: Timer?

    private let dynamicTypePrefix = "dyn."
    private let microsoftSourcePrefix = "com.microsoft.ole.source."
    private let supportedTypes: Set<NSPasteboard.PasteboardType> = [
        .fileURL,
        .html,
        .jpeg,
        .heic,
        .png,
        .rtf,
        .string,
        .tiff
    ]
    internal let ignoredTypes: Set<NSPasteboard.PasteboardType> = [
        .autoGenerated,
        .concealed,
        .transient
    ]

    internal var enabledTypes: Set<NSPasteboard.PasteboardType> { Defaults[.enabledPasteboardTypes] }
    internal var disabledTypes: Set<NSPasteboard.PasteboardType> { supportedTypes.subtracting(enabledTypes) }

    internal var sourceApp: NSRunningApplication? { NSWorkspace.shared.frontmostApplication }

    // Image file extensions that we should load as image data
    internal let imageFileExtensions: Set<String> = [
        "jpg", "jpeg", "png", "gif", "bmp", "tiff", "tif", "heic", "heif", "webp"
    ]

    init() {
        changeCount = pasteboard.changeCount
    }

    func onNewCopy(_ hook: @escaping OnNewCopyHook) {
        onNewCopyHooks.append(hook)
    }

    func clearHooks() {
        onNewCopyHooks = []
    }

    func start() {
        timer = Timer.scheduledTimer(
            timeInterval: Defaults[.clipboardCheckInterval],
            target: self,
            selector: #selector(checkForChangesInPasteboard),
            userInfo: nil,
            repeats: true
        )
    }

    func restart() {
        timer?.invalidate()
        start()
    }

    @MainActor
    func copy(_ string: String) {
        pasteboard.clearContents()
        pasteboard.setString(string, forType: .string)
        sync()
        checkForChangesInPasteboard()
    }

    @MainActor
    func copy(_ item: HistoryItem?, removeFormatting: Bool = false) {
        guard let item else { return }

        pasteboard.clearContents()
        var contents = item.contents

        if removeFormatting {
            contents = clearFormatting(contents)
        }

        // Check if this item contains file URLs
        let hasFileURL = contents.contains { $0.type == NSPasteboard.PasteboardType.fileURL.rawValue }

        // If item has file URLs, exclude image data to prevent pasting both file and thumbnail
        if hasFileURL {
            let imageTypes: Set<String> = [
                NSPasteboard.PasteboardType.tiff.rawValue,
                NSPasteboard.PasteboardType.png.rawValue,
                NSPasteboard.PasteboardType.jpeg.rawValue,
                NSPasteboard.PasteboardType.heic.rawValue
            ]
            contents = contents.filter { content in
                // Keep file URLs and non-image types, but exclude image data
                content.type == NSPasteboard.PasteboardType.fileURL.rawValue || !imageTypes.contains(content.type)
            }
        }

        for content in contents {
            guard content.type != NSPasteboard.PasteboardType.fileURL.rawValue else { continue }
            pasteboard.setData(content.value, forType: NSPasteboard.PasteboardType(content.type))
        }

        // Use writeObjects for file URLs so that multiple files that are copied actually work.
        // Only do this for file URLs because it causes an issue with some other data types (like formatted text)
        // where the item is pasted more than once.
        let fileURLItems: [NSPasteboardItem] = contents.compactMap { item in
            guard item.type == NSPasteboard.PasteboardType.fileURL.rawValue else { return nil }
            guard let value = item.value else { return nil }
            let pasteItem = NSPasteboardItem()
            pasteItem.setData(value, forType: NSPasteboard.PasteboardType(item.type))
            return pasteItem
        }
        pasteboard.writeObjects(fileURLItems)

        pasteboard.setString("", forType: .fromMaccy)
        pasteboard.setString(item.application ?? "", forType: .source)
        sync()

        Task {
            Notifier.notify(body: item.title, sound: .knock)
            checkForChangesInPasteboard()
        }
    }

    // Based on https://github.com/Clipy/Clipy/blob/develop/Clipy/Sources/Services/PasteService.swift.
    func paste() {
        Accessibility.check()

        // Add flag that left/right modifier key has been pressed.
        // See https://github.com/TermiT/Flycut/pull/18 for details.
        let cmdFlag = CGEventFlags(rawValue: UInt64(KeyChord.pasteKeyModifiers.rawValue) | 0x000008)
        var vCode = Sauce.shared.keyCode(for: KeyChord.pasteKey)

        // Force QWERTY keycode when keyboard layout switches to
        // QWERTY upon pressing ⌘ key (e.g. "Dvorak - QWERTY ⌘").
        // See https://github.com/p0deje/Maccy/issues/482 for details.
        if KeyboardLayout.current.commandSwitchesToQWERTY && cmdFlag.contains(.maskCommand) {
            vCode = KeyChord.pasteKey.QWERTYKeyCode
        }

        let source = CGEventSource(stateID: .combinedSessionState)
        // Disable local keyboard events while pasting
        source?.setLocalEventsFilterDuringSuppressionState([.permitLocalMouseEvents, .permitSystemDefinedEvents],
                                                           state: .eventSuppressionStateSuppressionInterval)

        let keyVDown = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: true)
        let keyVUp = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: false)
        keyVDown?.flags = cmdFlag
        keyVUp?.flags = cmdFlag
        keyVDown?.post(tap: .cgSessionEventTap)
        keyVUp?.post(tap: .cgSessionEventTap)
    }

    func clear() {
        guard Defaults[.clearSystemClipboard] else {
            return
        }

        pasteboard.clearContents()
    }

    @objc
    @MainActor
    func checkForChangesInPasteboard() {
        guard pasteboard.changeCount != changeCount else {
            return
        }

        changeCount = pasteboard.changeCount

        if Defaults[.ignoreEvents] {
            if Defaults[.ignoreOnlyNextEvent] {
                Defaults[.ignoreEvents] = false
                Defaults[.ignoreOnlyNextEvent] = false
            }

            return
        }

        // Reading types on NSPasteboard gives all the available
        // types - even the ones that are not present on the NSPasteboardItem.
        // See https://github.com/p0deje/Maccy/issues/241.
        if shouldIgnore(Set(pasteboard.types ?? [])) {
            return
        }

        if let sourceAppBundle = sourceApp?.bundleIdentifier, shouldIgnore(sourceAppBundle) {
            return
        }

        // Some applications (BBEdit, Edge) add 2 items to pasteboard when copying
        // so it's better to merge all data into a single record.
        // - https://github.com/p0deje/Maccy/issues/78
        // - https://github.com/p0deje/Maccy/issues/472
        var contents = [HistoryItemContent]()
        pasteboard.pasteboardItems?.forEach({ item in
            var types = Set(item.types)
            if types.contains(.string) && isEmptyString(item) && !richText(item) {
                return
            }

            if shouldIgnore(item) {
                return
            }

            types = types
                .subtracting(disabledTypes)
                .filter { !$0.rawValue.starts(with: dynamicTypePrefix) }
                .filter { !$0.rawValue.starts(with: microsoftSourcePrefix) }

            // Avoid reading Microsoft Word links from bookmarks and cross-references.
            // https://github.com/p0deje/Maccy/issues/613
            // https://github.com/p0deje/Maccy/issues/770
            if types.isSuperset(of: [.microsoftLinkSource, .microsoftObjectLink]) {
                types = types.subtracting([.microsoftLinkSource, .microsoftObjectLink, .pdf])
            }

            types.forEach { type in
                contents.append(HistoryItemContent(type: type.rawValue, value: item.data(forType: type)))
            }
        })

        guard !contents.isEmpty else {
            return
        }

        // Add image data for any image file URLs
        addImageDataFromFileURLs(&contents)

        let historyItem = HistoryItem()
        Storage.shared.context.insert(historyItem)

        historyItem.contents = contents
        historyItem.application = sourceApp?.bundleIdentifier
        historyItem.title = historyItem.generateTitle()

        onNewCopyHooks.forEach({ $0(historyItem) })
    }
}

// MARK: - Copy and Paste Operations Extensions
extension Clipboard {
    func clearFormatting(_ contents: [HistoryItemContent]) -> [HistoryItemContent] {
        var newContents: [HistoryItemContent] = contents
        let stringContents = contents.filter { NSPasteboard.PasteboardType($0.type) == .string }

        // If there is no string representation of data,
        // behave like we didn't have to remove formatting.
        if !stringContents.isEmpty {
            newContents = stringContents

            // Preserve file URLs.
            // https://github.com/p0deje/Maccy/issues/962
            let fileURLContents = contents.filter { NSPasteboard.PasteboardType($0.type) == .fileURL }
            if !fileURLContents.isEmpty {
                newContents += fileURLContents
            }
        }

        return newContents
    }

    // Some applications requires window be unfocused and focused back to sync the clipboard.
    // - Chrome Remote Desktop (https://github.com/p0deje/Maccy/issues/948)
    // - Netbeans (https://github.com/p0deje/Maccy/issues/879)
    func sync() {
        guard let app = sourceApp,
              app.bundleURL?.lastPathComponent == "Chrome Remote Desktop.app" ||
                app.localizedName?.contains("NetBeans") == true else {
            return
        }

        NSApp.activate(ignoringOtherApps: true)
        NSApp.hide(self)
    }
}

// MARK: - Pasteboard Validation Extensions
extension Clipboard {
    func shouldIgnore(_ types: Set<NSPasteboard.PasteboardType>) -> Bool {
        let ignoredTypes = self.ignoredTypes
            .union(Defaults[.ignoredPasteboardTypes].map({ NSPasteboard.PasteboardType($0) }))

        return types.isDisjoint(with: enabledTypes) ||
            !types.isDisjoint(with: ignoredTypes)
    }

    func shouldIgnore(_ sourceAppBundle: String) -> Bool {
        if Defaults[.ignoreAllAppsExceptListed] {
            return !Defaults[.ignoredApps].contains(sourceAppBundle)
        } else {
            return Defaults[.ignoredApps].contains(sourceAppBundle)
        }
    }

    func shouldIgnore(_ item: NSPasteboardItem) -> Bool {
        for regexp in Defaults[.ignoreRegexp] {
            if let string = item.string(forType: .string) {
                do {
                    let regex = try NSRegularExpression(pattern: regexp)
                    if regex.numberOfMatches(in: string, range: NSRange(string.startIndex..., in: string)) > 0 {
                        return true
                    }
                } catch {
                    return false
                }
            }
        }
        return false
    }

    func isEmptyString(_ item: NSPasteboardItem) -> Bool {
        guard let string = item.string(forType: .string) else {
            return true
        }

        return string.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }

    func richText(_ item: NSPasteboardItem) -> Bool {
        if let rtf = item.data(forType: .rtf) {
            if let attributedString = NSAttributedString(rtf: rtf, documentAttributes: nil) {
                return !attributedString.string.isEmpty
            }
        }

        if let html = item.data(forType: .html) {
            if let attributedString = NSAttributedString(html: html, documentAttributes: nil) {
                return !attributedString.string.isEmpty
            }
        }

        return false
    }
}

// MARK: - Image File Handling Extensions
extension Clipboard {
    func isImageFile(_ url: URL) -> Bool {
        let fileExtension = url.pathExtension.lowercased()
        return imageFileExtensions.contains(fileExtension)
    }

    func loadImageDataFromFileURL(_ url: URL) -> Data? {
        guard isImageFile(url), FileManager.default.fileExists(atPath: url.path) else {
            return nil
        }

        return try? Data(contentsOf: url)
    }

    func addImageDataFromFileURLs(_ contents: inout [HistoryItemContent]) {
        // Find file URL contents
        let fileURLContents = contents.filter { NSPasteboard.PasteboardType($0.type) == .fileURL }

        for fileURLContent in fileURLContents {
            guard let urlData = fileURLContent.value,
                  let url = URL(dataRepresentation: urlData, relativeTo: nil, isAbsolute: true),
                  let imageData = loadImageDataFromFileURL(url) else {
                continue
            }

            // Determine the appropriate pasteboard type based on file extension
            let fileExtension = url.pathExtension.lowercased()
            let pasteboardType: NSPasteboard.PasteboardType

            switch fileExtension {
            case "jpg", "jpeg":
                pasteboardType = .jpeg
            case "png":
                pasteboardType = .png
            case "tif", "tiff":
                pasteboardType = .tiff
            case "heic", "heif":
                pasteboardType = .heic
            default:
                // For other image types, convert to TIFF as a fallback
                if let nsImage = NSImage(data: imageData) {
                    if let tiffData = nsImage.tiffRepresentation {
                        contents.append(HistoryItemContent(
                          type: NSPasteboard.PasteboardType.tiff.rawValue,
                          value: tiffData
                        ))
                    }
                }
                continue
            }

            // Add the image data as the appropriate type
            contents.append(HistoryItemContent(type: pasteboardType.rawValue, value: imageData))
        }
    }
}
